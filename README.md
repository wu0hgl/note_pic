# 第2章 构造函数语意学 #

### 2.1默认构造函数的构造 ###

考虑如下代码
```
class Foo {
public: 
	int val;
	Foo *pnext;
}

void foo_bar() {
	// 程序要求bar's members都被清为0
	Foo bar;
	if (bar.val || bar.pnext) 
		// ... don something	
	// ...
}
```

上述代码是否会合成默认的构造函数? 这里有两个问题要弄明白:
- **编译器需要**
- **程序需要**: 上述代码就是"程序需要", 编译器会**声明**一个构造函数, 但是并**不会合成出来**, 所以还是没有构造函数, 在这种情况下为程序执行初始化应该是程序员的责任

那么在未来是否会合成默认构造函数:
- 在C++ Annotated Reference Mannual(ARM)中: 只有在编译器需要需要时才会合成默认的构造函数
- C++ Standard: 如果没有任何用户声明的构造函数(注意: 是任何声明的构造函数, 包括拷贝构造函数), 那么就会有一个默认构造函数被隐式的声明出来, 但是这样被声明出来的默认构造函数是trivial(浅薄无能, 就是没啥用)constructor. 只有当一个默认构造函数是nontrivial时, **才会被合成出来**. 所以, 上面的代码会声明一个trivial的默认构造函数, 但是因为是trivial, 所以不会合成出来, 编译器会报错

有4种情况, 会使编译器为没有声明构造函数的类**合成**一个默认构造函数, 即nontrivial的默认构造函数
1. **类包含带有默认构造函数的成员**, 合成出来的默认构造函数并不会初始化本类的其他成员, 初始化其他成员是程序员的责任
2. **类是由带有默认构造函数的基类所派生出来的**
3. **类中带有一个虚函数**
　　1. class声明或继承了一个虚函数
　　2. class派生自一个继承串链, 其中有一个或更多的虚基类
4. **类中带有一个虚基类** 有些疑问

**被合成出来的构造函数只能满足编译器(而非程序)的需要**, 它之所以能够完成任务, 是借着"调用成员对象或基类的默认构造函数"或是"为每一个对象初始化其虚函数机制或虚基类机制"而完成的

**在合成的默认构造函数中, 只有基类子对象和类成员对象会被初始化. 所有其他的nonstatic数据成员(如整数, 整数指针, 整数数组等等)都不会初始化. 这些初始化操作对程序而言或许有需要, 但对编译器则是非必要.** 如果程序需要一个"把某指针设为0"的默认构造函数, 那么提供它的人应该是程序员

> 总结就是都会声明, 但是会不会合成又是另一回事了, 取决于是trivial还是nontrivial

### 2.2拷贝构造函数的构造初始化 ###

有3种情况会以一个对象内容作为另一个对象的初值, 1. 显示以一个对象内容作为另一个对象的初值(初始化, 而不是单纯等号操作); 2. 当对象做参数交给某个函数(做形参, 非引用指针形式); 3. 对象做返回值(非引用指针形势)

- 默认逐位成员初始化(Default Memberwise Initialization)
- 逐成员初始化(Memberwise Initialization)
- 位逐次拷贝(Bitwise Copy Semantic)

如果累X没有显式的拷贝构造函数, 那么在用一个类X的
